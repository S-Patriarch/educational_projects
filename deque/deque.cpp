// deque.cpp -*- C++ -*-
// Copyright (c) S-Patriarch, 2023

// Дан массив и целое число k, найти максимум для каждого непрерывного 
// подмассива размера k. Другими словами, необходимо создать формат 
// вывода — максимум каждого подмассива k через пробел.

// Пример для массива { 1, 2, 3, 1, 4, 5, 2, 3, 6 } и k = 3.

// Вывод: 3 3 4 5 5 5 6
// Максимум { 1, 2, 3 } - 3
// Максимум { 2, 3, 1 } - 3
// Максимум { 3, 1, 4 } - 4
// Максимум { 1, 4, 5 } - 5
// Максимум { 4, 5, 2 } - 5
// Максимум { 5, 2, 3 } - 5
// Максимум { 2, 3, 6 } - 6

// Для решения данной задачи необходимо использовать подход 
// скользящего окна с использованием деки.

// Алгоритм:
//   1. Создать двухстороннюю очередь для хранения k элементов.
//   2. Запустить цикл и вставить первые k элементов в двухстороннюю 
//      очередь. Перед вставкой элемента проверить, меньше ли элемент в 
//      задней части очереди, чем текущий элемент. И если это так, 
//      удалить элемент из задней части двухсторонней очереди, пока все 
//      элементы, оставшиеся в двухсторонней очереди, не будут больше, 
//      чем текущий элемент. Затем вставить текущий элемент в конец 
//      двухсторонней очереди.
//   3. Запустить цикл от k до конца массива.
//   4. Распечатать передний элемент дека.
//   5. Удалить элемент из передней части очереди, если он находится 
//      вне текущего окна.
//   6. Вставить следующий элемент в двухстороннюю очередь. Перед 
//      вставкой элемента проверить, меньше ли элемент в задней части 
//      очереди, чем текущий элемент. И если это так, удалить элемент 
//      из задней части двухсторонней очереди, пока все элементы, 
//      оставшиеся в двухсторонней очереди, не будут больше, чем 
//      текущий элемент. Затем вставить текущий элемент в конец 
//      двухсторонней очереди.
//   7. Вывести максимальный элемент последнего окна.

#include <iostream>
#include <deque>
#include <vector>

typedef signed int  __s32;

std::vector<__s32> find_max(const std::vector<__s32>&, __s32);

//////////////////////////////////////////////////////////////////////
int
main()
{
  std::vector<__s32> _v{ 1, 2, 3, 1, 4, 5, 2, 3, 6 };
  __s32              _k{ 3 };

  std::vector<__s32> _maxValue{ ::find_max(_v, _k) };

  for (__s32 i{ 0 }; i < _maxValue.size(); i++)
  {
    std::cout << _maxValue[i]
              << " ";
  }

  std::cout << std::endl;
  return 0;
}

//--------------------------------------------------------------------
// Поиск максимума для каждого непрерывного подмассива размера _k.
//
std::vector<__s32> 
find_max(const std::vector<__s32>& _v, __s32 _k)
{
  std::vector<__s32> _result;
  std::deque<__s32>  _d;

  // обработка первых _k элементов
  for (__s32 i{ 0 }; i < _k; i++)
  {
    // удаление элементов из дека, которые меньше текущего
    while (!_d.empty() && _v[i] >= _v[_d.back()])
    {
      _d.pop_back();
    }
    _d.push_back(i);
  }

  // первый элемент в деке является максимумом предыдущего 
  // подмассива
  _result.push_back(_v[_d.front()]);

  // обработка остальных подмассивов
  for (__s32 i{ _k }; i < _v.size(); i++)
  {
    // удаляем из дека элементы, которые не принадлежат текущему 
    // подмассиву
    while (!_d.empty() && _d.front() <= i - _k)
    {
      _d.pop_front();
    }

    // удаление элементов из дека, которые меньше текущего
    while (!_d.empty() && _v[i] >= _v[_d.back()])
    {
      _d.pop_back();
    }

    _d.push_back(i);
    _result.push_back(_v[_d.front()]);
  }

  return _result;
}
